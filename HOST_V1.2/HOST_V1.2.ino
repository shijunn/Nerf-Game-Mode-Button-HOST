// Author: Tan Shi Jun

// announcer voice: ai generated from elevenlabs.io
// countdown effect: "Timer - digital countdown" by Bop Audio https://uppbeat.io/sfx/tag/countdown

// track 1: countdown beep
// track 2: start sound
// track 3: blue team announcer
// track 4: red team announcer

// to check serial monitor for ESP32 C6 Mini:
// tools -> USB CDC On Boot: "Enabled"

// current settings:
// board: ESP32C6 Dev Module
// USB CDC on boot: "Enabled"
// CPU frequency: 160MHz (WiFi)
// flash frequency: 80MHz
// flash mode: QIO
// flash size: 4MB
// partition scheme: 4MB with spiffs
// upload speed: 921600

#if !defined( ESP32 )
  #error This code is intended to run on the ESP32 platform! Please check your Tools->Board setting.
#endif

#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>
#include <Adafruit_NeoPixel.h>
#include <Preferences.h> // https://randomnerdtutorials.com/esp32-save-data-permanently-preferences/
#include <esp_now.h>  // https://randomnerdtutorials.com/esp-now-one-to-many-esp32-esp8266/
#include <WiFi.h>
#include <YX5300_ESP32.h> // https://github.com/bluejunimo/YX5300_ESP32
#include <Wire.h>
#include <esp_wifi.h>

#define NUM_PIXELS 32
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3c
#define devdebug
// #define calibrate_stick // for callibrating joystick
#define RW_MODE false
#define RO_MODE true
#define TX 16
#define RX 17

const int neopixelpin = 19;
const int joystick = 2;      // joystick
const int cancelButton = 4;  // OTA button
const int extButton = 5;     // external button

// average reading threshold
// values vary on different boards
const int LEFT_JOYSTICK_THRESHOLD_MIN = 750;
const int LEFT_JOYSTICK_THRESHOLD_MAX = 850;
const int RIGHT_JOYSTICK_THRESHOLD_MIN = 2340;
const int RIGHT_JOYSTICK_THRESHOLD_MAX = 2380;
const int MIDDLE_JOYSTICK_THRESHOLD_MIN = 1940;
const int MIDDLE_JOYSTICK_THRESHOLD_MAX = 1970;
const int DOWN_JOYSTICK_THRESHOLD_MIN = 1520;
const int DOWN_JOYSTICK_THRESHOLD_MAX = 1550;
const int UP_JOYSTICK_THRESHOLD_MIN = 320;
const int UP_JOYSTICK_THRESHOLD_MAX = 370;

const int visiblerows = 3; // rows visible on display
int menuoffset = 0;
//const int totalItems = 7;
const int visiblerows2 = 2;
int menuoffset2 = 0;
//const int totalItems2 = 2;


/*
why is enum used 
https://www.reddit.com/r/learnprogramming/comments/yk8d84/comment/iurxecv/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
*/
enum gamemodes
{ // start from 0 because of icon arrays later on
  CAPTURE_THE_FLAG = 0,  // enum automatically adds the next integer so
  DOMINATION,            // 2
  KING_OF_THE_HILL,      // 3
  CLICKER_DOMINATION,    // 4
  CHESS_CLOCK,           // 5
  SETTING,               // 6
  BOARD_NUMBER,          // 7
  NUM_MODES              // 8, if game modes are added or removed down the line, enum will automatically change the integer of NUM_MODES
};

int reading = 0;
int avgReading = 0;
int lastmenu = -1;
int menu = CAPTURE_THE_FLAG;     // menu = 1
int laststate = HIGH;
int buttonstate;
int defaultbuttonstate = HIGH;
bool startedrecording = false;
bool pressed = false;
bool storedPrev = false;
bool savesettings = false;

Preferences preferences;

uint8_t broadcastAddressBlue[] = {0xe4, 0xb3, 0x23, 0x94, 0x3b, 0x00};
uint8_t broadcastAddressRed[] = {0xe4, 0xb3, 0x23, 0x94, 0x3b, 0x14};
esp_now_peer_info_t peerInfo;

unsigned long pressedTime;
unsigned long longpressduration;
unsigned long startGameTime;
unsigned long startPressTime;
unsigned long prevTime;
unsigned long totalTime;
unsigned long lastdebouncetime = 0;
unsigned long debouncedelay = 25;
unsigned long timesetting = 0;
unsigned long countdownsetting = 0;
unsigned long longpress = 0;
uint32_t sendmodetime;

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
Adafruit_NeoPixel pixels(NUM_PIXELS, neopixelpin, NEO_GRB + NEO_KHZ800);
YX5300_ESP32 mp3;

// 'icon_chess', 16x16px
const unsigned char icon_chess [] PROGMEM = {
	0x03, 0xc0, 0x01, 0x80, 0x07, 0xe0, 0x08, 0x10, 0x10, 0x08, 0x20, 0x34, 0x40, 0x62, 0x40, 0xc2, 
	0x41, 0x82, 0x41, 0x82, 0x40, 0x02, 0x40, 0x02, 0x20, 0x04, 0x10, 0x08, 0x08, 0x10, 0x07, 0xe0
};
// 'icon_clicker', 16x16px
const unsigned char icon_clicker [] PROGMEM = {
	0x00, 0x00, 0x0f, 0xf0, 0x10, 0x08, 0x20, 0x04, 0x20, 0x04, 0x30, 0x0c, 0x28, 0x14, 0x67, 0xe6, 
	0xa0, 0x05, 0xa0, 0x05, 0xa0, 0x05, 0x98, 0x19, 0x87, 0xe1, 0x40, 0x02, 0x30, 0x0c, 0x0f, 0xf0
};
// 'icon_domination', 16x16px
const unsigned char icon_domination [] PROGMEM = {
	0x03, 0xc0, 0x1c, 0x38, 0x20, 0x04, 0x40, 0x02, 0x4a, 0x52, 0x84, 0x21, 0x8a, 0x51, 0x80, 0x01, 
	0x80, 0x01, 0x8f, 0xf1, 0x81, 0x21, 0x41, 0x22, 0x40, 0xc2, 0x20, 0x04, 0x1c, 0x38, 0x03, 0xc0
};
// 'icon_KOTH', 16x16px
const unsigned char icon_KOTH [] PROGMEM = {
	0x41, 0x82, 0xa2, 0x45, 0x94, 0x29, 0x89, 0x91, 0xa1, 0x85, 0x80, 0x01, 0x7f, 0xfe, 0x00, 0x00, 
	0x03, 0xc0, 0x04, 0x60, 0x0e, 0x10, 0x10, 0x0c, 0x10, 0x06, 0x20, 0xc3, 0x4c, 0x01, 0x80, 0x08
};
// 'icon_settings', 16x16px
const unsigned char icon_settings [] PROGMEM = {
	0x01, 0x80, 0x12, 0x48, 0x2a, 0x54, 0x44, 0x22, 0x20, 0x04, 0x11, 0x88, 0x62, 0x46, 0x84, 0x21, 
	0x84, 0x21, 0x62, 0x46, 0x11, 0x88, 0x20, 0x04, 0x44, 0x22, 0x2a, 0x54, 0x12, 0x48, 0x01, 0x80
};
// 'icon-ctf', 16x16px
const unsigned char icon_ctf [] PROGMEM = {
	0x00, 0x00, 0x38, 0x06, 0xc6, 0x19, 0x81, 0xe1, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 
	0xb8, 0x06, 0xc6, 0x18, 0x81, 0xe0, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00
};

// 'icon_countdown', 16x16px
const unsigned char icon_countdown [] PROGMEM = {
	0x03, 0xc0, 0x01, 0x80, 0x07, 0xe0, 0x08, 0x10, 0x13, 0x08, 0x27, 0x04, 0x4f, 0x02, 0x5f, 0x02, 
	0x5f, 0x02, 0x5f, 0xfa, 0x5f, 0xfa, 0x4f, 0xf2, 0x27, 0xe4, 0x13, 0xc8, 0x08, 0x10, 0x07, 0xe0
};
// 'icon_gametime', 16x16px
const unsigned char icon_gametime [] PROGMEM = {
	0x7f, 0xfe, 0x40, 0x02, 0x20, 0x04, 0x10, 0x08, 0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01, 0x80, 
	0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x90, 0x11, 0x08, 0x20, 0x04, 0x7c, 0xea, 0x7f, 0xfe
};

// boot up logo
const unsigned char ifb_logo [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0f, 0xff, 
	0xff, 0xff, 0xff, 0xf8, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x07, 0xff, 
	0xff, 0xff, 0xff, 0xf8, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xc0, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 
	0xff, 0xff, 0xf8, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 
	0xff, 0xff, 0xf8, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 
	0xff, 0xff, 0xf0, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 
	0xff, 0xff, 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xff, 0xff, 0xe0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 
	0xff, 0xff, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 
	0xff, 0xff, 0xc0, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 
	0xff, 0xff, 0xc0, 0x00, 0x80, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0x80, 0x01, 0x80, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 
	0xff, 0xff, 0x00, 0x01, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 
	0xff, 0xff, 0x00, 0x03, 0x00, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 
	0xff, 0xfe, 0x00, 0x02, 0x00, 0x07, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 
	0xff, 0xfe, 0x00, 0x06, 0x00, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x1f, 0xff, 
	0xff, 0xfc, 0x00, 0x04, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x3f, 0xff, 
	0xff, 0xfc, 0x00, 0x0c, 0x00, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x3f, 0xff, 
	0xff, 0xf8, 0x00, 0x08, 0x00, 0x1f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x7f, 0xff, 
	0xff, 0xf8, 0x00, 0x18, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x7f, 0xff, 
	0xff, 0xf0, 0x00, 0x10, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0xff, 0xff, 
	0xff, 0xf0, 0x00, 0x30, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0xff, 0xf0, 0xff, 0xff, 
	0xff, 0xe0, 0x00, 0x20, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0xff, 0xf1, 0xff, 0xff, 
	0xff, 0xe0, 0x00, 0x60, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x01, 0xff, 0xe1, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x40, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x01, 0xff, 0xe3, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0xc0, 0x00, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x03, 0xff, 0xc3, 0xff, 0xff, 
	0xff, 0x80, 0x00, 0x80, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x03, 0xff, 0xc7, 0xff, 0xff, 
	0xff, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xff, 0x87, 0xff, 0xff, 
	0xff, 0x00, 0x01, 0x00, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xff, 0x0f, 0xff, 0xff, 
	0xff, 0x00, 0x03, 0x00, 0x03, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x07, 0xfe, 0x0f, 0xff, 0xff, 
	0xfe, 0x00, 0x06, 0x00, 0x07, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 
	0xfe, 0x00, 0x04, 0x00, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 
	0xfc, 0x00, 0x0c, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const char* menuLabels[] = {"Flag", "Dom", "KOTH", "Clicker", "Chess", "Settings", "Board No."};
const uint8_t* menuIcons[] = {icon_ctf, icon_domination, icon_KOTH, icon_clicker, icon_chess, icon_settings, icon_settings};

const char* menuLabels2[] = {"Game time", "Countdown"};
const uint8_t* menuIcons2[] = {icon_gametime, icon_countdown};



typedef struct game_struct
{
  int score;
  unsigned long gamemodetime;
  bool endgame;
  unsigned long checktime;
  unsigned long newTime;
  unsigned long testtime;
  unsigned long recordedTime;
  int modenum;
  bool confirm;
  unsigned long countdowntime;
  int id;
  int togglescreen;
  bool middlelongpressed;
  bool goback;
  bool button;
} game_struct;

game_struct gamedata; // storing data on this board (host)
game_struct incominggamedata; // for team or host board
game_struct board1;
game_struct board2;
game_struct boards[2] = {board1, board2};

// create variables to assign values from the recv callback function to update and store new values
bool board1_endgame;
bool board2_endgame;
bool board1_button;
bool board2_button;
int board1_score;
int board2_score;
unsigned long board1_testtime;
unsigned long board2_testtime;
unsigned long board1_recordedTime;
unsigned long board2_recordedTime;
unsigned long board1_checktime;
unsigned long board2_checktime;
unsigned long board1_newTime;
unsigned long board2_newTime;



void readstick();
void oledDisplayCenter();
void oledDisplayInt();
void oledDisplayCountdown();
void oledDisplayStrInt();
void oledDisplayTime();
void menudisplay();
void resetvariables();
void resetscore();
void colorWipe(uint32_t c, uint8_t wait);
void setting();
void checkendgame();
void checkscore();
void checkprogress();
void togglescreenfunction();
void readstickinsettings();
void sendgamemode();
void sendall();
void drawmenu();
void drawmenu2();





void setup() {
  Serial.begin(115200);
  mp3 = YX5300_ESP32(Serial1, RX, TX); // connected to "Serial0" on PCB
  #ifdef devdebug
    mp3.enableDebugging();
  #endif
  mp3.setVolume(30); // 0 to 30
  Wire.begin(6, 7);
  WiFi.mode(WIFI_STA);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  esp_now_register_send_cb(OnDataSent);
  
  // Register peer
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  // register blue team as a peer
  memcpy(peerInfo.peer_addr, broadcastAddressBlue, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK)
  {
    Serial.println("Failed to add peer");
    return;
  }
  //register red team as a peer
  memcpy(peerInfo.peer_addr, broadcastAddressRed, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK)
  {
    Serial.println("Failed to add peer");
    return;
  }

  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;  // Don't proceed, loop forever
  }
  display.clearDisplay();
  display.drawBitmap(0, 0, ifb_logo, 128, 64, 1);
  display.display();

  pixels.begin();
  pixels.clear();
  pixels.show();
  pixels.setBrightness(30);

  pinMode(joystick, INPUT);
  pinMode(cancelButton, INPUT);
  pinMode(extButton, INPUT);

  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  

  // INITIALIZE PREFERENCES HERE
  preferences.begin("settings", RW_MODE);
  gamedata.gamemodetime = preferences.getULong("game_duration", 0);
  gamedata.countdowntime = preferences.getULong("game_countdown", 0);


  // setting defaults for variables to be sent to team boards
  // UNCOMMENT GAMEMODETIME AND COUNTDOWNTIME WHEN NOT USING PREFERENCES
  //gamedata.gamemodetime = 0;
  gamedata.modenum = CAPTURE_THE_FLAG;
  gamedata.confirm = false;
  //gamedata.countdowntime = 0;
  gamedata.togglescreen = 0;
  gamedata.middlelongpressed = false;
  gamedata.goback = false;

  esp_now_register_recv_cb(esp_now_recv_cb_t(OnDataRecv));
  sendall();
  delay(1000);
}

void loop() {
  #ifdef calibrate_stick // define calibrate_stick to use
    for(int n = 0; n<10;n++)
    {
      reading = reading + analogRead(joystick);
    }
    avgReading = reading/10;
    Serial.println(String(avgReading)+"avg");
    delay(500);
    reading = 0;
    avgReading = 0;
  #else // if calibrate_stick is not defined
    readstick();
    menudisplay(); // update display on team board with gamedata.modenum

    if (gamedata.middlelongpressed) {

      display.clearDisplay();
      display.display();

      /*
      GAME MODES
      1. capture the flag     -      3 mins, press to stop
      2. domination           -      3 mins, least number of clicks wins, start from 0
      3. king of the hill     -      5 mins, press and hold, start from 0
      4. clicker domination   -      3 mins, start from 0, most clicks wins
      5. chess clock          -      start from time limit, press once, timer goes down
      */

      switch (menu) {
        
        case CAPTURE_THE_FLAG:  // 3 mins, press to stop
          preferences.end();
          gamedata.confirm = true;
          sendall(); // send a bool to team board to start countdown
          oledDisplayCountdown(gamedata.countdowntime); // countdown on host screen before checking whether the team board set endgame flag to true
          checkendgame(); // recieves updates from teams and displays scores on oled
          break;

        case DOMINATION:
          preferences.end();
          gamedata.confirm = true;
          sendall();
          oledDisplayCountdown(gamedata.countdowntime);
          checkscore(); // receives updates from teams and displays time on oled
          break;

        case KING_OF_THE_HILL:
          preferences.end();
          gamedata.confirm = true;
          sendall();
          oledDisplayCountdown(gamedata.countdowntime);
          checkprogress();
          break;

        case CLICKER_DOMINATION:
          preferences.end();
          gamedata.confirm = true;
          sendall();
          oledDisplayCountdown(gamedata.countdowntime);
          checkscore();
          break;
        
        case CHESS_CLOCK:
          preferences.end();
          gamedata.confirm = true;
          sendall();
          oledDisplayCountdown(gamedata.countdowntime);
          checkprogress();
          break;

        case SETTING:
          gamedata.confirm = true;
          sendall();
          setting();
          break;

        case BOARD_NUMBER:
          gamedata.confirm = true;
          sendall();
          break;

        default:
          Serial.println("ERROR AT STARTING GAME SWITCH CASE");
          break;
      }
      resetvariables();
    }
  #endif
}